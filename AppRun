#!/bin/bash

# AppRun wrapper for Linux System Monitor AppImage
# Automatically requests elevated privileges if needed

# Get the directory where the AppImage is mounted
# In AppImage, $0 points to AppRun in the mounted directory
# The executable should be in the same directory as AppRun
APP_DIR="$(dirname "$(readlink -f "$0")")"
EXECUTABLE="$APP_DIR/linux-system-monitor"

# Verify executable exists
if [ ! -f "$EXECUTABLE" ]; then
    echo "Error: Cannot find linux-system-monitor executable in $APP_DIR" >&2
    exit 1
fi

# Function to check if we need elevated privileges
needs_privileges() {
    # Check if we can read RAPL power data (requires root on some systems)
    if [ ! -r "/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj" ] 2>/dev/null; then
        # Also check if we're already root
        if [ "$(id -u)" -ne 0 ]; then
            return 0  # Needs privileges and we're not root
        fi
    fi
    return 1  # Doesn't need privileges
}

# Function to launch with GUI privilege prompt
launch_with_privileges() {
    local display_server="x11"
    
    # Detect display server
    if [ -n "$WAYLAND_DISPLAY" ] || [ "$XDG_SESSION_TYPE" = "wayland" ]; then
        display_server="wayland"
    fi
    
    # Try GUI password prompt with sudo (most reliable approach)
    local password=""
    if command -v zenity >/dev/null 2>&1; then
        password=$(zenity --password --title="Linux System Monitor - Privileges Required" \
            --text="Administrator privileges are required to access Intel RAPL power monitoring data.\n\nPlease enter your password:" 2>/dev/null)
    elif command -v kdialog >/dev/null 2>&1; then
        password=$(kdialog --password "Administrator privileges are required to access Intel RAPL power monitoring data.\n\nPlease enter your password:" 2>/dev/null)
    fi
    
    if [ -n "$password" ]; then
        # Create a wrapper script that sudo can execute
        # This avoids issues with AppImage mount paths and permissions
        local wrapper_script="/tmp/.linux-system-monitor-wrapper-$$.sh"
        cat > "$wrapper_script" << 'WRAPPER_EOF'
#!/bin/bash
# Wrapper script to run AppImage with preserved environment
export DISPLAY="$DISPLAY"
export WAYLAND_DISPLAY="$WAYLAND_DISPLAY"
export XDG_SESSION_TYPE="$XDG_SESSION_TYPE"
export XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR"
export XDG_CONFIG_HOME="$XDG_CONFIG_HOME"
export XDG_DATA_HOME="$XDG_DATA_HOME"
export HOME="$HOME"
export USER="$USER"
export PATH="$PATH"
export LANG="$LANG"
export LC_ALL="$LC_ALL"
export ELECTRON_DISABLE_GPU=1
export ELECTRON_DISABLE_GPU_COMPOSITING=1
export ELECTRON_DISABLE_GPU_SANDBOX=1

# Get values from environment variables passed by sudo
APPIMAGE_VAR="${APPIMAGE}"
EXECUTABLE_VAR="${APP_EXECUTABLE}"
DISPLAY_SERVER_VAR="${APP_DISPLAY_SERVER}"

# Use APPIMAGE environment variable if available (preferred)
if [ -n "$APPIMAGE_VAR" ] && [ -f "$APPIMAGE_VAR" ]; then
    exec "$APPIMAGE_VAR" --no-sandbox --ozone-platform="$DISPLAY_SERVER_VAR" "$@"
else
    # Fallback to executable path
    exec "$EXECUTABLE_VAR" --no-sandbox --ozone-platform="$DISPLAY_SERVER_VAR" "$@"
fi
WRAPPER_EOF
        chmod 755 "$wrapper_script"
        
        # Get original AppImage path (if running from AppImage)
        local original_appimage="${APPIMAGE:-}"
        if [ -z "$original_appimage" ] && [ -f "$EXECUTABLE" ]; then
            # If not set, try to get from the executable's location
            # This handles the case where we're not running from the AppImage directly
            original_appimage="$EXECUTABLE"
        fi
        
        # Run sudo with the wrapper script, passing APPIMAGE and executable path via env
        echo "$password" | sudo -E env \
             DISPLAY="$DISPLAY" \
             WAYLAND_DISPLAY="$WAYLAND_DISPLAY" \
             XDG_SESSION_TYPE="$XDG_SESSION_TYPE" \
             XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR" \
             APPIMAGE="$original_appimage" \
             APP_EXECUTABLE="$EXECUTABLE" \
             APP_DISPLAY_SERVER="$display_server" \
             "$wrapper_script" "$@"
        
        local exit_code=$?
        rm -f "$wrapper_script"
        exit $exit_code
    elif command -v pkexec >/dev/null 2>&1; then
        # Fallback to pkexec if GUI password prompt failed
        # Use a simple wrapper script
        local wrapper_script="/tmp/.linux-system-monitor-$$.sh"
        printf '#!/bin/bash\nexport DISPLAY="%s"\nexport WAYLAND_DISPLAY="%s"\nexport XDG_RUNTIME_DIR="%s"\nexport HOME="%s"\nexport USER="%s"\nexec "%s" --no-sandbox --ozone-platform="%s" "$@"\n' \
               "$DISPLAY" "$WAYLAND_DISPLAY" "$XDG_RUNTIME_DIR" "$HOME" "$USER" \
               "$EXECUTABLE" "$display_server" > "$wrapper_script"
        chmod 755 "$wrapper_script"
        pkexec "$wrapper_script" "$@"
        local exit_code=$?
        rm -f "$wrapper_script"
        exit $exit_code
    # Fallback to gksu/gksudo (X11 only)
    elif command -v gksu >/dev/null 2>&1 && [ "$display_server" = "x11" ]; then
        gksu "$EXECUTABLE --no-sandbox --ozone-platform=$display_server"
    elif command -v gksudo >/dev/null 2>&1 && [ "$display_server" = "x11" ]; then
        gksudo "$EXECUTABLE --no-sandbox --ozone-platform=$display_server"
    else
        # Last resort: show error message
        if command -v zenity >/dev/null 2>&1; then
            zenity --error --title="Linux System Monitor" \
                --text="Unable to request elevated privileges.\n\nPlease run manually with:\nsudo $EXECUTABLE --no-sandbox"
        elif command -v kdialog >/dev/null 2>&1; then
            kdialog --error "Unable to request elevated privileges.\n\nPlease run manually with:\nsudo $EXECUTABLE --no-sandbox"
        else
            echo "Error: Unable to request elevated privileges." >&2
            echo "Please run manually with: sudo $EXECUTABLE --no-sandbox" >&2
        fi
        exit 1
    fi
}

# Main execution
if needs_privileges; then
    # Check if we can access power data - if not, we need privileges
    launch_with_privileges
else
    # No privileges needed - run normally
    exec "$EXECUTABLE" "$@"
fi

