#!/bin/bash

# AppRun wrapper for Linux System Monitor AppImage
# Automatically requests elevated privileges if needed

# Get the directory where the AppImage is mounted
# In AppImage, $0 points to AppRun in the mounted directory
# The executable should be in the same directory as AppRun
APP_DIR="$(dirname "$(readlink -f "$0")")"
EXECUTABLE="$APP_DIR/linux-system-monitor"

# Verify executable exists
if [ ! -f "$EXECUTABLE" ]; then
    echo "Error: Cannot find linux-system-monitor executable in $APP_DIR" >&2
    exit 1
fi

# Function to check if we need elevated privileges
needs_privileges() {
    # Check if we can read RAPL power data (requires root on some systems)
    # Check multiple possible RAPL paths
    local rapl_paths=(
        "/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj"
        "/sys/class/powercap/intel-rapl/intel-rapl:1/energy_uj"
        "/sys/class/powercap/intel-rapl:0/energy_uj"
    )
    
    local can_read_rapl=false
    for rapl_path in "${rapl_paths[@]}"; do
        if [ -r "$rapl_path" ] 2>/dev/null; then
            can_read_rapl=true
            break
        fi
    done
    
    # Also check if we're already root
    if [ "$(id -u)" -eq 0 ]; then
        return 1  # Already root, doesn't need elevation
    fi
    
    # If we can't read RAPL and we're not root, we need privileges
    if [ "$can_read_rapl" = false ]; then
        return 0  # Needs privileges
    fi
    
    return 1  # Doesn't need privileges
}

# Function to setup X11 authentication for root access
setup_x11_auth() {
    # For X11, try to allow localhost connections as fallback
    if [ -n "$DISPLAY" ] && command -v xhost >/dev/null 2>&1; then
        # Allow localhost connections (safe, only if xhost available)
        # Note: This is a fallback if XAUTHORITY cookie copying fails
        xhost +local: >/dev/null 2>&1 || true
    fi
}

# Function to launch with GUI privilege prompt
launch_with_privileges() {
    local display_server="x11"
    
    # Detect display server
    if [ -n "$WAYLAND_DISPLAY" ] || [ "$XDG_SESSION_TYPE" = "wayland" ]; then
        display_server="wayland"
    fi
    
    # Setup X11 authentication before elevating
    if [ "$display_server" = "x11" ]; then
        setup_x11_auth
    fi
    
    # Get original AppImage path (if running from AppImage)
    local original_appimage="${APPIMAGE:-}"
    if [ -z "$original_appimage" ] && [ -f "$EXECUTABLE" ]; then
        # Try to find the original AppImage path
        # When AppImage is mounted, $0 points to AppRun, but we need the original file
        local script_dir="$(dirname "$(readlink -f "$0")")"
        # Check if we're in a mounted AppImage directory
        if [ -f "$script_dir/../AppRun" ] || [ -f "$script_dir/../../AppRun" ]; then
            # We're in a mounted AppImage, try to get the original path
            # Check common AppImage mount points
            if [ -n "$APPIMAGE" ]; then
                original_appimage="$APPIMAGE"
            elif [ -f "/proc/self/mountinfo" ]; then
                # Try to get mount source from /proc/self/mountinfo
                local mount_source=$(grep "$script_dir" /proc/self/mountinfo 2>/dev/null | head -1 | awk '{print $5}')
                if [ -n "$mount_source" ] && [ -f "$mount_source" ]; then
                    original_appimage="$mount_source"
                fi
            fi
        fi
    fi
    
    # If we still don't have the original AppImage path, we can't run as root
    # Fall back to running without elevation
    if [ -z "$original_appimage" ] && [ "$(id -u)" -eq 0 ]; then
        echo "Error: Cannot determine original AppImage path when running as root" >&2
        exit 1
    fi
    
    # Try GUI password prompt with sudo (retry loop for wrong password)
    local max_attempts=3
    local attempt=0
    local password=""
    local sudo_success=false
    
    while [ $attempt -lt $max_attempts ]; do
        attempt=$((attempt + 1))
        password=""
        
        # Prompt for password graphically
        if command -v zenity >/dev/null 2>&1; then
            if [ $attempt -eq 1 ]; then
                password=$(zenity --password --title="Linux System Monitor - Privileges Required" \
                    --text="Administrator privileges are required to access Intel RAPL power monitoring data.\n\nPlease enter your password:" 2>/dev/null)
            else
                password=$(zenity --password --title="Linux System Monitor - Privileges Required" \
                    --text="Authentication failed. Please try again.\n\nAttempt $attempt of $max_attempts:" 2>/dev/null)
            fi
        elif command -v kdialog >/dev/null 2>&1; then
            if [ $attempt -eq 1 ]; then
                password=$(kdialog --password "Administrator privileges are required to access Intel RAPL power monitoring data.\n\nPlease enter your password:" 2>/dev/null)
            else
                password=$(kdialog --password "Authentication failed. Please try again.\n\nAttempt $attempt of $max_attempts:" 2>/dev/null)
            fi
        fi
        
        # If user cancelled (empty password from GUI)
        if [ -z "$password" ]; then
            # User cancelled - exit gracefully
            exit 0
        fi
        
        # Test sudo with this password
        if echo "$password" | sudo -S true 2>/dev/null; then
            sudo_success=true
            break
        fi
    done
    
    if [ "$sudo_success" = true ] && [ -n "$password" ]; then
        # Create a wrapper script that sudo can execute
        # This avoids issues with AppImage mount paths and permissions
        local wrapper_script="/tmp/.linux-system-monitor-wrapper-$$.sh"
        cat > "$wrapper_script" << 'WRAPPER_EOF'
#!/bin/bash
# Wrapper script to run AppImage with preserved environment and X11 authentication

# Preserve display environment
export DISPLAY="${DISPLAY}"
export WAYLAND_DISPLAY="${WAYLAND_DISPLAY}"
export XDG_SESSION_TYPE="${XDG_SESSION_TYPE}"
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME}"
export XDG_DATA_HOME="${XDG_DATA_HOME}"
export HOME="${HOME}"
export USER="${USER}"
export PATH="${PATH}"
export LANG="${LANG}"
export LC_ALL="${LC_ALL}"

# Critical: Preserve X11 authentication
export XAUTHORITY="${XAUTHORITY}"
if [ -z "$XAUTHORITY" ] && [ -n "$HOME" ]; then
    # Default X11 auth file location
    export XAUTHORITY="$HOME/.Xauthority"
fi

# If XAUTHORITY points to a user's home file, try to use it or copy it
if [ -n "$XAUTHORITY" ] && [ -f "$XAUTHORITY" ]; then
    # Copy X11 auth cookie to temp location accessible by root
    local temp_xauth="/tmp/.Xauthority-$$-$(whoami)"
    if cp "$XAUTHORITY" "$temp_xauth" 2>/dev/null; then
        chmod 644 "$temp_xauth"
        export XAUTHORITY="$temp_xauth"
    fi
fi

# Electron GPU flags to avoid rendering issues
export ELECTRON_DISABLE_GPU=1
export ELECTRON_DISABLE_GPU_COMPOSITING=1
export ELECTRON_DISABLE_GPU_SANDBOX=1

# Get values from environment variables passed by sudo
APPIMAGE_VAR="${APPIMAGE}"
EXECUTABLE_VAR="${APP_EXECUTABLE}"
DISPLAY_SERVER_VAR="${APP_DISPLAY_SERVER}"

# Use APPIMAGE environment variable if available (preferred)
# When running as root via sudo, we need to execute the original AppImage file,
# not the mounted executable, so the AppImage runtime can remount it properly
if [ -n "$APPIMAGE_VAR" ] && [ -f "$APPIMAGE_VAR" ]; then
    # Execute the original AppImage file - AppImage runtime will handle mounting
    exec "$APPIMAGE_VAR" --no-sandbox --ozone-platform="$DISPLAY_SERVER_VAR" "$@"
else
    # Fallback: try to find the original AppImage path
    # If we can't find it, show an error
    echo "Error: Cannot determine original AppImage path" >&2
    echo "Please run the AppImage directly, not via sudo" >&2
    exit 1
fi
WRAPPER_EOF
        chmod 755 "$wrapper_script"
        
        # Preserve X11 authentication cookie path
        local xauth="${XAUTHORITY:-$HOME/.Xauthority}"
        
        # Run sudo with the wrapper script, passing APPIMAGE and executable path via env
        # Critical: Preserve X11 authentication environment
        # Use -S to accept password from stdin
        echo "$password" | sudo -S -E env \
             DISPLAY="$DISPLAY" \
             WAYLAND_DISPLAY="$WAYLAND_DISPLAY" \
             XDG_SESSION_TYPE="$XDG_SESSION_TYPE" \
             XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR" \
             XAUTHORITY="$xauth" \
             HOME="$HOME" \
             USER="$USER" \
             APPIMAGE="$original_appimage" \
             APP_EXECUTABLE="$EXECUTABLE" \
             APP_DISPLAY_SERVER="$display_server" \
             "$wrapper_script" "$@"
        
        local exit_code=$?
        rm -f "$wrapper_script"
        
        # Clear password from memory (security best practice)
        password=""
        unset password
        
        exit $exit_code
    elif command -v pkexec >/dev/null 2>&1; then
        # Fallback to pkexec if GUI password prompt failed
        # Use a simple wrapper script
        local wrapper_script="/tmp/.linux-system-monitor-$$.sh"
        printf '#!/bin/bash\nexport DISPLAY="%s"\nexport WAYLAND_DISPLAY="%s"\nexport XDG_RUNTIME_DIR="%s"\nexport HOME="%s"\nexport USER="%s"\nexec "%s" --no-sandbox --ozone-platform="%s" "$@"\n' \
               "$DISPLAY" "$WAYLAND_DISPLAY" "$XDG_RUNTIME_DIR" "$HOME" "$USER" \
               "$EXECUTABLE" "$display_server" > "$wrapper_script"
        chmod 755 "$wrapper_script"
        pkexec "$wrapper_script" "$@"
        local exit_code=$?
        rm -f "$wrapper_script"
        exit $exit_code
    # Fallback to gksu/gksudo (X11 only)
    elif command -v gksu >/dev/null 2>&1 && [ "$display_server" = "x11" ]; then
        gksu "$EXECUTABLE --no-sandbox --ozone-platform=$display_server"
    elif command -v gksudo >/dev/null 2>&1 && [ "$display_server" = "x11" ]; then
        gksudo "$EXECUTABLE --no-sandbox --ozone-platform=$display_server"
    else
        # Last resort: show error message
        if command -v zenity >/dev/null 2>&1; then
            zenity --error --title="Linux System Monitor" \
                --text="Unable to request elevated privileges.\n\nPlease run manually with:\nsudo $EXECUTABLE --no-sandbox"
        elif command -v kdialog >/dev/null 2>&1; then
            kdialog --error "Unable to request elevated privileges.\n\nPlease run manually with:\nsudo $EXECUTABLE --no-sandbox"
        else
            echo "Error: Unable to request elevated privileges." >&2
            echo "Please run manually with: sudo $EXECUTABLE --no-sandbox" >&2
        fi
        exit 1
    fi
}

# Main execution
if needs_privileges; then
    # Check if we can access power data - if not, we need privileges
    launch_with_privileges
else
    # No privileges needed - run normally
    exec "$EXECUTABLE" "$@"
fi

